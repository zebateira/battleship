class GameEngine
	types
	values
	instance variables
		--houses : set of House;
		public p1: Player;
		public p2: Player;
		public board1own : Board;
		public board1play : Board;
		public board2own : Board;
		public board2play : Board;
		public activePlayer: int := 1;
		public win : bool := false;
		
		inv activePlayer = 1 or activePlayer = 2;
		
	operations
	
		public there : () ==> ()
			there() ==
				IO`println(3);
		
		public GameEngine : int ==> GameEngine
			GameEngine (boardSize) ==
			(
				board1own := new Board(genHouses(boardSize), false);
				board1play := new Board(genHouses(boardSize), true);
				board2own := new Board(genHouses(boardSize), false);
				board2play := new Board(genHouses(boardSize), true);
				p1 := new Player("player1", board1own,board1play);
				p2 := new Player("player2", board2own,board2play);
				startGame();
			);

		public startGame : () ==> ()
			startGame () ==
			(
				while not win do
				(
					if activePlayer = 1 then
						let coords = p1.play(board1own.size) in
						(
							board1play.mark(coords, board2own.hit(coords));
							activePlayer := 2;
							
							win := checkVictory(p2.ships);
						)
					else
						let coords2 = p2.play(board1own.size) in
						(
							board2play.mark(coords2, board1own.hit(coords2));
							activePlayer := 1;
							
							win := checkVictory(p1.ships);
						);
				);
			);
		
		public checkVictory: seq of Ship ==> bool
			checkVictory (ships) ==
			(
				return true;	
			)
		pre forall s in set elems ships & s.isDown();	
			
		public genHouses : int ==> set of House
			genHouses(s) ==
			(
				dcl xx : set of int, yy :set of int, houses : set of House := {};
				xx := {1,...,s};
				yy := {1,...,s};
				
				
				for all x in set xx do
				(
					for all y in set yy do
					(
						houses := houses union {new House(x,y)};
						IO`println([x] ^ [y]);
					)
				);
				
				IO`println(houses);
				
				return houses;
			);

	functions
	traces
end GameEngine