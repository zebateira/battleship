class Ship
	types
		public coord = seq of int;
		
	values
		orientations : map int to (seq of int) = {0|->[0,-1],1|->[1,0],2|->[0,1],3|->[-1,0]};
		
	instance variables
	public coord_init : coord;
	public coords : set of coord := {};
	public orientation : int := 1;
	public hits : int := 0;
	public size: int := 1;
	public player : int;
	
	-- 0 -> up
	-- 1 -> right
	-- 2 -> down
	-- 3 -> left
	inv orientation >= 0 and orientation <= 3;
	inv len coord_init = 2;
	--inv len coord = 2;
	
	inv card(coords) >= 0 and card(coords) <= size;
	
	operations
	
	public Ship: coord * int * int * Board ==> Ship --* Board ==> Ship
	Ship(c,o,s,b) == 
	(
		coord_init := c;
		size := s;
		coords := {c};
		orientation := o;
		
		for i = 1 to size do
		(	
			coords := coords union {[c(1)+orientations(o)(1)*i,c(2)+orientations(o)(2)*i]};
		);
	)
	pre	forall x in set {c(1),c(1)+orientations(o)(1)*s,c(2),c(2)+orientations(o)(2)*s} &
			x>=0 and x<=b.size
	post fill_houses(b);
	
		
	public fill_houses: Board ==> bool
		fill_houses(b) ==
		(
			for all c in set coords do
			(
				if player = 1 then
				(
					let h in set b.houses be st h.x = c(1) and h.y = c(2) in
					(
						 if(h.hasShip) then return false
						 else h.hasShip := true;
					)
				)
				elseif player = 2 then
				(
					let h in set b.houses be st h.x = c(1) and h.y = c(2) in
					(
						 if(h.hasShip) then return false
						 else h.hasShip := true;
					)
				)
			);
			return true;
		);
	--pre forall c in set coords &
		--	forall h in set GameEngine
			 
	public inc: () ==> ()
	inc() == hits := hits +1;
	
	public isDown : () ==> bool
	isDown() == return size = hits;
-- TODO Define operations here
	functions
-- TODO Define functiones here
	traces
-- TODO Define Combinatorial Test Traces here
end Ship