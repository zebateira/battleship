class Ship
	types
		public coord = seq of int;
		
	values
		orientations : map int to (seq of int) = {0|->[0,-1],1|->[1,0],2|->[0,1],3|->[-1,0]};
		
		
	instance variables
	public static id : int := 0;
	public coord_init : coord;
	public coords : set of coord := {};
	public orientation : int := 1;
	public hits : int := 0;
	public size: int := 1;
	public board: Board;
	public my_id: int;
	
	-- 0 -> up
	-- 1 -> right
	-- 2 -> down
	-- 3 -> left
	inv orientation >= 0 and orientation <= 3;
	inv len coord_init = 2;
	inv id >= 0;
	
	inv card(coords) >= 0 and card(coords) <= size;
	
	operations
	
	public Ship: coord * int * int * Board ==> Ship --* Board ==> Ship
	Ship(c,o,s,b) == 
	(
		coord_init := c;
		size := s;
		coords := {c};
		orientation := o;
		board := b;
		my_id := id +1;
		
		for i = 1 to size do
		(	
			coords := coords union {[c(1)+orientations(o)(1)*i,c(2)+orientations(o)(2)*i]};
		);
		
		id := my_id;
	)
	pre	forall x in set {c(1),c(1)+orientations(o)(1)*s,c(2),c(2)+orientations(o)(2)*s} &
			x>=0 and x<=board.size
	post fill_houses();
	
		
	public fill_houses: ()==> bool
		fill_houses() ==
		(
			for all c in set coords do
			(
				let h in set board.houses be st h.x = c(1) and h.y = c(2) in
				(
					h.hasShip := true;
					h.ship := self;
				)
			);
			return true;
		)
	pre forall c in set coords &
		let h in set board.houses be st h.x = c(1) and h.y = c(2) in
		(
			not h.hasShip
		);
			 
	public inc: () ==> ()
	inc() == hits := hits +1;
	
	public isDown : () ==> bool
	isDown() == return size = hits;
-- TODO Define operations here
	functions
-- TODO Define functiones here
	traces
-- TODO Define Combinatorial Test Traces here
end Ship