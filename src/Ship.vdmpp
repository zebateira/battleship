class Ship
	types
		coord = seq of int;
	values
		orientations : map int to (seq of int) = {0|->[0,-1],1|->[1,0],2|->[0,1],3|->[-1,0]};
		
	instance variables
	public coord_init : coord;
	public coords : set of coord := {};
	public orientation : int := 1;
	public hits : int := 0;
	public size: int := 1;
	public player : int;
	
	-- 0 -> up
	-- 1 -> right
	-- 2 -> down
	-- 3 -> left
	inv orientation >= 0 and orientation <= 3;
	
	inv len coord = 2;
	
	inv card(coords) >= 0 and card(coords) <= size;
	
	operations
	
	public Ship: coord * int * int * int ==> bool
	Ship(c,o,s,p) == 
	(
		coord_init := c;
		size := s;
		coords := {c};
		orientation := o;
		player := p;
		
		for i = 1 to size do
		(	
			new_coord:=[c(1)+orientations(o)(1)*i,c(2)+orientations(o)(2)*i];
			coords := coords union {new_coord};
			
		);
		
		if not fill_houses() then return false
		else return true;
	)
	pre	forall x in set {c(1),c(1)+orientations(o)(1)*s,c(2),c(2)+orientations(o)(2)*s} &
			x>=0 and x<=GameEngine.board1own.size;
	
	
	private fill_houses: () ==> bool
		fill_houses() ==
		(
			for all c in set coords do
			(
				if player = 1 then
				(
					let h in set GameEngine.board1own.houses be st h.x = c(1) and h.y = c(2) in
					(
						 if(h.hasShip) then return false
						 else h.hasShip := true;
					)
				)
				elseif player = 2 then
				(
					let h in set GameEngine.board2own.houses be st h.x = c(1) and h.y = c(2) in
					(
						 if(h.hasShip) then return false
						 else h.hasShip := true;
					)
				)
			);
			return true;
		)
	pre forall c in set coords &
			forall h in set GameEngine
			 
	public inc: () ==> ()
	inc() == hits := hits +1;
	
	public isDown : () ==> bool
	isDown() == return size = hits;
-- TODO Define operations here
	functions
-- TODO Define functiones here
	traces
-- TODO Define Combinatorial Test Traces here
end Ship